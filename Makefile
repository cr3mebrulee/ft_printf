## First lets define some variables.
# Later reference variables by putting them into brackets and prefixing with $, like $(CC)
CC=cc       # The compiler to be used
CFLAGS=-I.  # Flags to be passed to the compiler
DEPS=ft.h   # Global dependencies
# All the object files to be linked in the end
OBJS=ft_printf.o ft_character.o ft_char_length.o ft_hexadecimal.o ft_number.o ft_pointer.o ft_string.o ft_unsigned.o


# Now lets define targets.
# On the left side of the colon the target, on the right side its dependencies.
# On the next line a tab and then the command how to generate the target.
# Targets to be generated by Make can be passed with the make command, like
# make ft_printf_test
# If no target is passed Make will try to generate the fist target defined in the Makefile.


## Definition how to build ft_printf_test
# This is the default target if no target is passed to the make command.
# ft_printf_test depends on ft_printf_test.c and the files defined in OBJS.
# So Make looks for the files ft_printf_test, ft_printf_test.c and the OBJS files.
# If Make can not find ft_printf_test.c it bails out because we don't have a rule to generate it.
# If Make can not find one of the files defined in OBJS it jumps to the rule we defined to build these object files.
# If Make found all ther dependencies and ft_printf_test doesn't exist yet or is older then one of the files
# in the dependencies it tries to (re)build ft_printf_test.
# $@ is the variable for the target, in this case ft_printf_test.
# $^ is the variable for all the defined dependencies.
# So actually it will execute
# cc -o ft_printf_test ft_printf_test.c ft_printf.o ft_character.o ft_char_length.o ft_hexadecimal.o ft_number.o ft_pointer.o ft_string.o ft_unsigned.o -I.
ft_printf_test: ft_printf_test.c $(OBJS)
	$(CC) -o $@ $^ $(CFLAGS)


# Meta defintion how to build a target <name>.o, aka an object file.
# Whenever Make encounters a dependency <name>.o it will jump to this rule to generate it.
# The target <name>.o (%.o) depends on a file <name>.c (%.c) and the files defined above in DEBS.
# Make looks for the files <name>.o, <name>.c and the DEBS files,
# If it doesn't find <name>.c or one of the DEBS files, it bails out because we didn't define rules for how to generate any of them.
# If it doesn't find <name>.o or it <name>.o is older then <name>.c or one of the DEBS files it tries to (re)build <name>.o
# If <name>.o exits and is younger then the DEBS files Make will do nothing.
# $@ is the variable for the target, in this case <name>.o
# $< is the variable for the first defined dependency, in this case <name>.c
# So actually it will execute
# cc -o <name>.o <name>.c -I.
%.o: %.c $(DEPS)
	$(CC) -c -o $@ $< $(CFLAGS)


# A pseudo target to remove the intermediate object files defined in OBJS
# Make looks for a file with the name 'clean', can't find it so it executes the action.
# But this action doesn't generate a file named clean, so the action gets always executed.
# So just call
# make clean
# to clean up the directory from unwanted intermediate files.
clean:
	rm -f $(OBJS)


# Make a weather report
weather:
	curl wttr.in
